#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Bot Verificador de Citas de Extranjer√≠a - Castell√≥n
Prop√≥sito: Ayuda social para detectar disponibilidad de citas (SOLO VERIFICACI√ìN)
Versi√≥n: 2.1 (Flujo completo corregido con rutas absolutas y TLS estable)
"""

import os
import sys
import json
import time
import random
import logging
import smtplib
import re
from datetime import datetime
from pathlib import Path
from email.mime.text import MIMEText  # ‚úÖ CORRECTO: .text no _text
from email.mime.multipart import MIMEMultipart

import requests
from bs4 import BeautifulSoup
import certifi

# ========= RUTAS ABSOLUTAS BASADAS EN LA UBICACI√ìN REAL DEL ARCHIVO =========
PROJECT_ROOT = Path(__file__).resolve().parent.parent  # src/ -> ra√≠z del proyecto
LOGS_DIR = PROJECT_ROOT / "logs"
DATA_DIR = PROJECT_ROOT / "data"
CONFIG_DIR = PROJECT_ROOT / "config"

# Crear directorios si no existen
for directory in [LOGS_DIR, DATA_DIR, CONFIG_DIR]:
    directory.mkdir(parents=True, exist_ok=True)

# ========= LOGGING CON RUTA ABSOLUTA =========
log_file = LOGS_DIR / "citas_extranjeria.log"
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s",
    handlers=[
        logging.FileHandler(str(log_file), encoding="utf-8"),
        logging.StreamHandler(sys.stdout)
    ]
)

class CitasExtranjeriaBot:
    """
    Bot √©tico para verificar disponibilidad de citas (solo verificaci√≥n).
    Sigue el flujo completo del sitio web oficial con sesiones y formularios.
    """

    def __init__(self):
        self.session = requests.Session()
        # TLS estable con certifi
        self.session.verify = certifi.where()
        logging.info(f"üîí Bundle de certificados: {self.session.verify}")
        
        # Headers realistas para parecer navegador
        self.session.headers.update({
            "User-Agent": "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 "
                          "(KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
            "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8",
            "Accept-Language": "es-ES,es;q=0.9,en;q=0.8",
            "Accept-Encoding": "gzip, deflate, br",
            "Connection": "keep-alive",
            "Upgrade-Insecure-Requests": "1",
            "Sec-Fetch-Dest": "document",
            "Sec-Fetch-Mode": "navigate",
            "Sec-Fetch-Site": "none",
        })

        # Configuraci√≥n √©tica
        self.DELAY_MIN = 3.0
        self.DELAY_MAX = 6.0
        
        # Datos de prueba (solo para verificaci√≥n)
        self.TEST_NIE = "X5492368Z"
        self.TEST_NOMBRE = "Miriam Malasquez"
        
        # Control de estado
        self.ultima_respuesta = None
        self.session_activa = False

    def _esperar(self):
        """Espera √©tica entre peticiones"""
        tiempo = random.uniform(self.DELAY_MIN, self.DELAY_MAX)
        logging.info(f"‚è±Ô∏è  Esperando {tiempo:.1f}s (comportamiento √©tico)")
        time.sleep(tiempo)

    def _guardar_html(self, contenido, nombre):
        """Guarda HTML para depuraci√≥n"""
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        archivo = DATA_DIR / f"{nombre}_{timestamp}.html"
        try:
            archivo.write_text(contenido, encoding="utf-8")
            logging.debug(f"üìÑ HTML guardado: {archivo.name}")
        except Exception as e:
            logging.error(f"‚ùå Error guardando HTML: {e}")

    def _extraer_tokens_formulario(self, html):
        """Extrae campos ocultos y tokens CSRF"""
        if not html:
            return {}
            
        soup = BeautifulSoup(html, 'html.parser')
        tokens = {}
        
        for input_field in soup.find_all('input', type='hidden'):
            name = input_field.get('name')
            value = input_field.get('value', '')
            if name:
                tokens[name] = value
                logging.debug(f"üîë Token: {name}={value[:20]}...")
        
        return tokens

    def paso1_pagina_inicial(self):
        """Paso 1: P√°gina inicial del sistema"""
        logging.info("üìç Paso 1: Accediendo a p√°gina inicial...")
        url = "https://icp.administracionelectronica.gob.es/icpplus/index.html"
        
        try:
            response = self.session.get(url, timeout=30)
            response.raise_for_status()
            
            self.ultima_respuesta = response.text
            self._guardar_html(response.text, "paso1_inicial")
            self.session_activa = True
            
            logging.info("‚úÖ Paso 1: P√°gina inicial cargada correctamente")
            return True
            
        except Exception as e:
            logging.error(f"‚ùå Error en paso 1: {e}")
            return False

    def paso2_seleccionar_provincia(self):
        """Paso 2: Seleccionar provincia Castell√≥n"""
        logging.info("üìç Paso 2: Seleccionando provincia Castell√≥n...")
        url = "https://icp.administracionelectronica.gob.es/icpplus/citar"
        
        try:
            # GET con par√°metros para Castell√≥n
            params = {"p": "12", "locale": "es"}
            response = self.session.get(url, params=params, timeout=30)
            response.raise_for_status()
            
            self.ultima_respuesta = response.text
            self._guardar_html(response.text, "paso2_provincia")
            
            logging.info("‚úÖ Paso 2: Provincia Castell√≥n seleccionada")
            return True
            
        except Exception as e:
            logging.error(f"‚ùå Error en paso 2: {e}")
            return False

    def paso3_oficina_tramite(self):
        """Paso 3: Seleccionar oficina y tr√°mite"""
        logging.info("üìç Paso 3: Configurando oficina y tr√°mite...")
        url = "https://icp.administracionelectronica.gob.es/icpplus/acInfo"
        
        try:
            # Extraer tokens del formulario anterior
            tokens = self._extraer_tokens_formulario(self.ultima_respuesta)
            
            # Datos del formulario
            data = {
                "sede": "12408",           # CNP COMISARIA CASTELLON
                "tramiteGrupo[0]": "4010", # POLICIA-CERTIFICADOS
                "tramiteGrupo[1]": "",
                "provincia": "12",
                **tokens
            }
            
            headers = {
                "Content-Type": "application/x-www-form-urlencoded",
                "Referer": "https://icp.administracionelectronica.gob.es/icpplus/citar?p=12&locale=es",
                "Origin": "https://icp.administracionelectronica.gob.es"
            }
            
            response = self.session.post(url, data=data, headers=headers, timeout=30)
            response.raise_for_status()
            
            self.ultima_respuesta = response.text
            self._guardar_html(response.text, "paso3_oficina")
            
            logging.info("‚úÖ Paso 3: Oficina y tr√°mite configurados")
            return True
            
        except Exception as e:
            logging.error(f"‚ùå Error en paso 3: {e}")
            return False

    def paso4_entrada_sin_clave(self):
        """Paso 4: Acceso sin Cl@ve"""
        logging.info("üìç Paso 4: Seleccionando entrada sin Cl@ve...")
        url = "https://icp.administracionelectronica.gob.es/icpplus/acEntrada"
        
        try:
            response = self.session.get(url, timeout=30)
            response.raise_for_status()
            
            self.ultima_respuesta = response.text
            self._guardar_html(response.text, "paso4_entrada")
            
            logging.info("‚úÖ Paso 4: P√°gina de entrada sin Cl@ve cargada")
            return True
            
        except Exception as e:
            logging.error(f"‚ùå Error en paso 4: {e}")
            return False

    def paso5_validar_datos(self):
        """Paso 5: Introducir y validar datos"""
        logging.info("üìç Paso 5: Validando datos de usuario...")
        url = "https://icp.administracionelectronica.gob.es/icpplus/acValidarEntrada"
        
        try:
            tokens = self._extraer_tokens_formulario(self.ultima_respuesta)
            
            data = {
                "nie": self.TEST_NIE,
                "nombre": self.TEST_NOMBRE,
                "paisNacimiento": "",
                "annoNacimiento": "",
                **tokens
            }
            
            headers = {
                "Content-Type": "application/x-www-form-urlencoded",
                "Referer": "https://icp.administracionelectronica.gob.es/icpplus/acEntrada",
                "Origin": "https://icp.administracionelectronica.gob.es"
            }
            
            response = self.session.post(url, data=data, headers=headers, timeout=30)
            response.raise_for_status()
            
            self.ultima_respuesta = response.text
            self._guardar_html(response.text, "paso5_validar")
            
            logging.info("‚úÖ Paso 5: Datos validados correctamente")
            return True
            
        except Exception as e:
            logging.error(f"‚ùå Error en paso 5: {e}")
            return False

    def paso6_verificar_citas(self):
        """Paso 6: Verificar disponibilidad de citas"""
        logging.info("üìç Paso 6: Verificando disponibilidad de citas...")
        url = "https://icp.administracionelectronica.gob.es/icpplus/acCitar"
        
        try:
            response = self.session.get(url, timeout=30)
            response.raise_for_status()
            
            self.ultima_respuesta = response.text
            self._guardar_html(response.text, "paso6_citas")
            
            # An√°lisis del contenido
            contenido = response.text.lower()
            
            # Patrones de NO disponibilidad
            no_disponible = [
                "no hay citas disponibles",
                "no existen citas",
                "en este momento no hay citas",
                "actualmente no hay citas",
                "sin citas disponibles"
            ]
            
            # Patrones de S√ç disponibilidad
            si_disponible = [
                "seleccione fecha",
                "seleccionar fecha",
                "calendario",
                "ui-datepicker",
                "fechas disponibles"
            ]
            
            # Determinar disponibilidad
            if any(patron in contenido for patron in no_disponible):
                hay_citas = False
                mensaje = "‚ùå NO HAY CITAS DISPONIBLES (confirmado por texto)"
                logging.info(mensaje)
            elif any(patron in contenido for patron in si_disponible):
                hay_citas = True
                mensaje = "üéâ ¬°HAY CITAS DISPONIBLES! (calendario detectado)"
                logging.critical(mensaje)
            else:
                # An√°lisis m√°s profundo con BeautifulSoup
                soup = BeautifulSoup(response.text, 'html.parser')
                elementos_citas = (
                    soup.find('div', class_='ui-datepicker') or
                    soup.find('input', {'type': 'date'}) or
                    soup.find('select', {'name': re.compile('fecha', re.I)})
                )
                
                if elementos_citas:
                    hay_citas = True
                    mensaje = "üéâ ¬°HAY CITAS DISPONIBLES! (elementos de fecha detectados)"
                    logging.critical(mensaje)
                else:
                    hay_citas = False
                    mensaje = "‚ö†Ô∏è  Estado indeterminado - No se detectaron citas claras"
                    logging.warning(mensaje)
            
            return {
                "hay_citas": hay_citas,
                "mensaje": mensaje,
                "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
                "url_final": response.url
            }
            
        except Exception as e:
            logging.error(f"‚ùå Error en paso 6: {e}")
            return {
                "hay_citas": False,
                "mensaje": f"Error en verificaci√≥n: {str(e)}",
                "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
                "url_final": url
            }

    def verificar_disponibilidad_completa(self):
        """Ejecuta el flujo completo de verificaci√≥n"""
        logging.info("üöÄ === INICIANDO VERIFICACI√ìN COMPLETA DE CITAS ===")
        
        try:
            # Reiniciar sesi√≥n para cada verificaci√≥n
            self.session.close()
            self.session = requests.Session()
            self.session.verify = certifi.where()
            self.session.headers.update({
                "User-Agent": "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 "
                              "(KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
                "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8",
                "Accept-Language": "es-ES,es;q=0.9",
            })
            
            # Ejecutar flujo paso a paso
            pasos = [
                ("P√°gina inicial", self.paso1_pagina_inicial),
                ("Seleccionar provincia", self.paso2_seleccionar_provincia), 
                ("Configurar oficina", self.paso3_oficina_tramite),
                ("Entrada sin clave", self.paso4_entrada_sin_clave),
                ("Validar datos", self.paso5_validar_datos)
            ]
            
            for nombre_paso, funcion_paso in pasos:
                if not funcion_paso():
                    return {
                        "hay_citas": False,
                        "mensaje": f"Error en: {nombre_paso}",
                        "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                    }
                self._esperar()  # Espera √©tica entre pasos
            
            # Verificar citas (paso final)
            resultado = self.paso6_verificar_citas()
            
            # Procesar resultado
            self.guardar_resultado(resultado)
            
            if resultado["hay_citas"]:
                self.crear_alerta_local(resultado)
                self.enviar_notificacion_email(resultado)
            
            return resultado
            
        except Exception as e:
            logging.error(f"‚ùå Error durante verificaci√≥n completa: {e}")
            return {
                "hay_citas": False,
                "mensaje": f"Error general: {str(e)}",
                "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            }
        finally:
            logging.info("üèÅ === VERIFICACI√ìN COMPLETA FINALIZADA ===\n")

    def guardar_resultado(self, resultado):
        """Guarda resultado en CSV con ruta absoluta"""
        csv_path = DATA_DIR / "resultados_citas.csv"
        es_nuevo = not csv_path.exists()
        
        try:
            with open(csv_path, "a", encoding="utf-8") as f:
                if es_nuevo:
                    f.write("timestamp,hay_citas,mensaje,url_final\n")
                f.write(f'{resultado["timestamp"]},{resultado["hay_citas"]},"{resultado["mensaje"]}",{resultado.get("url_final", "N/A")}\n')
            logging.info("üíæ Resultado guardado en CSV")
        except Exception as e:
            logging.error(f"‚ùå Error guardando resultado: {e}")

    def crear_alerta_local(self, resultado):
        """Crea archivo de alerta en data/"""
        alert_path = DATA_DIR / "üö®_CITAS_DISPONIBLES_üö®.txt"
        try:
            with open(alert_path, "w", encoding="utf-8") as f:
                f.write("üö®üö®üö® ¬°¬°¬°CITAS DISPONIBLES DETECTADAS!!! üö®üö®üö®\n\n")
                f.write(f"üìÖ Fecha y hora: {resultado['timestamp']}\n")
                f.write(f"üí¨ Detalle: {resultado['mensaje']}\n")
                f.write(f"üîó URL: {resultado.get('url_final', 'N/A')}\n\n")
                f.write("üöÄ ACCI√ìN INMEDIATA REQUERIDA:\n")
                f.write("1. Ve AHORA al sitio web oficial\n")
                f.write("2. Reserva la cita MANUALMENTE\n")
                f.write("3. NO uses bots para reservar\n\n")
                f.write("‚öñÔ∏è  RECORDATORIO: Solo verificaci√≥n, no reserva autom√°tica\n")
            logging.critical("üö® ¬°ARCHIVO DE ALERTA CREADO! Revisa data/")
        except Exception as e:
            logging.error(f"‚ùå Error creando alerta: {e}")

    def enviar_notificacion_email(self, resultado):
        """Env√≠a notificaci√≥n por email si est√° configurado"""
        config_path = CONFIG_DIR / "email_config.json"
        if not config_path.exists():
            logging.info("üìß Email no configurado")
            return
            
        try:
            with open(config_path, "r", encoding="utf-8") as f:
                config = json.load(f)
                
            msg = MIMEMultipart()
            msg["From"] = config["email"]
            msg["To"] = config["destinatario"]
            msg["Subject"] = "üö® ALERTA: CITAS EXTRANJER√çA DISPONIBLES"
            
            cuerpo = f"""
¬°CITAS DISPONIBLES DETECTADAS!

Timestamp: {resultado['timestamp']}
Mensaje: {resultado['mensaje']}
URL: {resultado.get('url_final', 'N/A')}

IMPORTANTE: Accede manualmente al sitio para reservar.
Este bot solo verifica disponibilidad.
"""
            msg.attach(MIMEText(cuerpo, "plain", "utf-8"))
            
            with smtplib.SMTP(config["smtp_server"], config["smtp_port"]) as server:
                server.starttls()
                server.login(config["email"], config["password"])
                server.sendmail(config["email"], config["destinatario"], msg.as_string())
                
            logging.info("üìß Notificaci√≥n enviada por email")
            
        except Exception as e:
            logging.error(f"‚ùå Error enviando email: {e}")

    def monitor_continuo(self, intervalo_minutos=10, max_verificaciones=None):
        """Monitor continuo con control √©tico"""
        logging.info("üîÑ === INICIANDO MONITOR CONTINUO ===")
        logging.info(f"‚è±Ô∏è  Intervalo: {intervalo_minutos} minutos")
        logging.info(f"üî¢ M√°ximo verificaciones: {'Ilimitado' if not max_verificaciones else max_verificaciones}")
        
        contador = 0
        try:
            while True:
                contador += 1
                logging.info(f"\nüìä --- Verificaci√≥n #{contador} ---")
                
                resultado = self.verificar_disponibilidad_completa()
                
                if resultado["hay_citas"]:
                    logging.critical("üéâ ¬°CITAS ENCONTRADAS! Revisa el sitio web INMEDIATAMENTE")
                    # Opcional: hacer verificaciones adicionales
                    for i in range(2):
                        time.sleep(30)
                        logging.info(f"üîÑ Verificaci√≥n adicional {i+1}/2...")
                        self.verificar_disponibilidad_completa()
                
                if max_verificaciones and contador >= max_verificaciones:
                    logging.info("‚úÖ L√≠mite de verificaciones alcanzado")
                    break
                
                # Esperar hasta la pr√≥xima verificaci√≥n
                logging.info(f"üí§ Pr√≥xima verificaci√≥n en {intervalo_minutos} minutos...")
                time.sleep(intervalo_minutos * 60)
                
        except KeyboardInterrupt:
            logging.info("\n‚èπÔ∏è  Monitor detenido por el usuario (Ctrl+C)")
        finally:
            logging.info("üèÅ === MONITOR FINALIZADO ===")

    def menu_principal(self):
        """Men√∫ interactivo principal"""
        print("=" * 70)
        print("üîç BOT VERIFICADOR DE CITAS EXTRANJER√çA - CASTELL√ìN")
        print("=" * 70)
        print("üìã Prop√≥sito: Ayuda social - Solo verificaci√≥n de disponibilidad")
        print("‚öñÔ∏è  Legal: NO reserva citas, solo detecta disponibilidad")
        print("üõ°Ô∏è  √âtico: Respeta l√≠mites del servidor con esperas")
        print("=" * 70)
        
        while True:
            print("\nüìã OPCIONES DISPONIBLES:")
            print("1Ô∏è‚É£  Verificaci√≥n √∫nica completa")
            print("2Ô∏è‚É£  Monitor continuo (cada 10 min)")
            print("3Ô∏è‚É£  Monitor personalizado")
            print("4Ô∏è‚É£  Configurar notificaciones email")
            print("5Ô∏è‚É£  Ver √∫ltimos resultados")
            print("0Ô∏è‚É£  Salir")
            
            try:
                opcion = input("\nüëâ Selecciona opci√≥n: ").strip()
                
                if opcion == "1":
                    print("\nüîç Ejecutando verificaci√≥n √∫nica...")
                    resultado = self.verificar_disponibilidad_completa()
                    print(f"\nüìä Resultado: {resultado['mensaje']}")
                    
                elif opcion == "2":
                    print("\nüîÑ Iniciando monitor continuo...")
                    print("üí° Presiona Ctrl+C para detener")
                    self.monitor_continuo(intervalo_minutos=10)
                    
                elif opcion == "3":
                    minutos = int(input("‚è±Ô∏è  Intervalo en minutos: ") or "10")
                    max_ver = input("üî¢ M√°ximo verificaciones (Enter = ilimitado): ").strip()
                    max_ver = int(max_ver) if max_ver else None
                    self.monitor_continuo(intervalo_minutos=minutos, max_verificaciones=max_ver)
                    
                elif opcion == "4":
                    self.configurar_email_interactivo()
                    
                elif opcion == "5":
                    self.mostrar_resultados_recientes()
                    
                elif opcion == "0":
                    print("\nüëã ¬°Gracias por usar el verificador!")
                    print("ü§ù Recuerda: Solo para ayuda social")
                    break
                    
                else:
                    print("‚ùå Opci√≥n no v√°lida")
                    
            except KeyboardInterrupt:
                print("\n‚èπÔ∏è  Operaci√≥n cancelada")
                continue
            except Exception as e:
                print(f"‚ùå Error: {e}")

    def configurar_email_interactivo(self):
        """Configuraci√≥n interactiva de email"""
        print("\nüìß CONFIGURACI√ìN DE NOTIFICACIONES EMAIL")
        print("=" * 50)
        try:
            smtp_server = input("üì° Servidor SMTP (ej: smtp.gmail.com): ")
            smtp_port = int(input("üîå Puerto SMTP (ej: 587): "))
            email = input("üìß Tu email: ")
            password = input("üîë Contrase√±a/App Password: ")
            destinatario = input("üìÆ Email destinatario: ")
            
            config = {
                "smtp_server": smtp_server,
                "smtp_port": smtp_port,
                "email": email,
                "password": password,
                "destinatario": destinatario
            }
            
            config_path = CONFIG_DIR / "email_config.json"
            with open(config_path, "w", encoding="utf-8") as f:
                json.dump(config, f, indent=2)
            
            print("‚úÖ Configuraci√≥n de email guardada")
            
        except Exception as e:
            print(f"‚ùå Error en configuraci√≥n: {e}")

    def mostrar_resultados_recientes(self):
        """Muestra los √∫ltimos resultados"""
        csv_path = DATA_DIR / "resultados_citas.csv"
        if not csv_path.exists():
            print("‚ÑπÔ∏è  No hay resultados previos")
            return
            
        try:
            with open(csv_path, "r", encoding="utf-8") as f:
                lineas = f.readlines()
            
            print(f"\nüìä √öLTIMOS {min(10, len(lineas)-1)} RESULTADOS:")
            print("=" * 50)
            
            for linea in lineas[-10:]:
                if not linea.startswith("timestamp"):
                    print(linea.strip())
                    
        except Exception as e:
            print(f"‚ùå Error leyendo resultados: {e}")

def main():
    """Funci√≥n principal"""
    try:
        bot = CitasExtranjeriaBot()
        bot.menu_principal()
    except Exception as e:
        logging.error(f"‚ùå Error cr√≠tico en main: {e}")
        print(f"‚ùå Error cr√≠tico: {e}")

if __name__ == "__main__":
    main()
