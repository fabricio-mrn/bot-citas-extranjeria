#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Bot Verificador de Citas de ExtranjerÃ­a - CastellÃ³n
PropÃ³sito: Ayuda social para detectar disponibilidad de citas (SOLO VERIFICACIÃ“N)
VersiÃ³n: 2.1 (Flujo completo corregido con rutas absolutas y TLS estable)
"""

import os
import sys
import json
import time
import random
import logging
import smtplib
import re
from datetime import datetime
from pathlib import Path
from email.mime.text import MIMEText  # âœ… CORRECTO: .text no _text
from email.mime.multipart import MIMEMultipart

import requests
from bs4 import BeautifulSoup
import certifi

# ========= RUTAS ABSOLUTAS BASADAS EN LA UBICACIÃ“N REAL DEL ARCHIVO =========
PROJECT_ROOT = Path(__file__).resolve().parent.parent  # src/ -> raÃ­z del proyecto
LOGS_DIR = PROJECT_ROOT / "logs"
DATA_DIR = PROJECT_ROOT / "data"
CONFIG_DIR = PROJECT_ROOT / "config"

# Crear directorios si no existen
for directory in [LOGS_DIR, DATA_DIR, CONFIG_DIR]:
    directory.mkdir(parents=True, exist_ok=True)

# ========= LOGGING CON RUTA ABSOLUTA =========
log_file = LOGS_DIR / "citas_extranjeria.log"
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s",
    handlers=[
        logging.FileHandler(str(log_file), encoding="utf-8"),
        logging.StreamHandler(sys.stdout)
    ]
)

class CitasExtranjeriaBot:
    """
    Bot Ã©tico para verificar disponibilidad de citas (solo verificaciÃ³n).
    Sigue el flujo completo del sitio web oficial con sesiones y formularios.
    """

    def __init__(self):
        self.session = requests.Session()
        # TLS estable con certifi
        self.session.verify = certifi.where()
        logging.info(f"ğŸ”’ Bundle de certificados: {self.session.verify}")
        
        # Headers realistas para parecer navegador
        self.session.headers.update({
            "User-Agent": "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 "
                          "(KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
            "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8",
            "Accept-Language": "es-ES,es;q=0.9,en;q=0.8",
            "Accept-Encoding": "gzip, deflate, br",
            "Connection": "keep-alive",
            "Upgrade-Insecure-Requests": "1",
            "Sec-Fetch-Dest": "document",
            "Sec-Fetch-Mode": "navigate",
            "Sec-Fetch-Site": "none",
        })

        # ConfiguraciÃ³n Ã©tica
        self.DELAY_MIN = 3.0
        self.DELAY_MAX = 6.0
        
        # Datos de prueba (solo para verificaciÃ³n)
        self.TEST_NIE = "X5492368Z"
        self.TEST_NOMBRE = "Miriam Malasquez"
        
        # Control de estado
        self.ultima_respuesta = None
        self.session_activa = False

    def _esperar(self):
        """Espera Ã©tica entre peticiones"""
        tiempo = random.uniform(self.DELAY_MIN, self.DELAY_MAX)
        logging.info(f"â±ï¸  Esperando {tiempo:.1f}s (comportamiento Ã©tico)")
        time.sleep(tiempo)

    def _guardar_html(self, contenido, nombre):
        """Guarda HTML para depuraciÃ³n"""
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        archivo = DATA_DIR / f"{nombre}_{timestamp}.html"
        try:
            archivo.write_text(contenido, encoding="utf-8")
            logging.debug(f"ğŸ“„ HTML guardado: {archivo.name}")
        except Exception as e:
            logging.error(f"âŒ Error guardando HTML: {e}")

    def _extraer_tokens_formulario(self, html):
        """Extrae campos ocultos y tokens CSRF"""
        if not html:
            return {}
            
        soup = BeautifulSoup(html, 'html.parser')
        tokens = {}
        
        for input_field in soup.find_all('input', type='hidden'):
            name = input_field.get('name')
            value = input_field.get('value', '')
            if name:
                tokens[name] = value
                logging.debug(f"ğŸ”‘ Token: {name}={value[:20]}...")
        
        return tokens

    def paso1_pagina_inicial(self):
        """Paso 1: PÃ¡gina inicial del sistema"""
        logging.info("ğŸ“ Paso 1: Accediendo a pÃ¡gina inicial...")
        url = "https://icp.administracionelectronica.gob.es/icpplus/index.html"
        
        try:
            response = self.session.get(url, timeout=30)
            response.raise_for_status()
            
            self.ultima_respuesta = response.text
            self._guardar_html(response.text, "paso1_inicial")
            self.session_activa = True
            
            logging.info("âœ… Paso 1: PÃ¡gina inicial cargada correctamente")
            return True
            
        except Exception as e:
            logging.error(f"âŒ Error en paso 1: {e}")
            return False

    def paso2_seleccionar_provincia(self):
        """Paso 2: Seleccionar provincia CastellÃ³n"""
        logging.info("ğŸ“ Paso 2: Seleccionando provincia CastellÃ³n...")
        url = "https://icp.administracionelectronica.gob.es/icpplus/citar"
        
        try:
            # GET con parÃ¡metros para CastellÃ³n
            params = {"p": "12", "locale": "es"}
            response = self.session.get(url, params=params, timeout=30)
            response.raise_for_status()
            
            self.ultima_respuesta = response.text
            self._guardar_html(response.text, "paso2_provincia")
            
            logging.info("âœ… Paso 2: Provincia CastellÃ³n seleccionada")
            return True
            
        except Exception as e:
            logging.error(f"âŒ Error en paso 2: {e}")
            return False

    def paso3_oficina_tramite(self):
        """Paso 3: Seleccionar oficina y trÃ¡mite"""
        logging.info("ğŸ“ Paso 3: Configurando oficina y trÃ¡mite...")
        url = "https://icp.administracionelectronica.gob.es/icpplus/acInfo"
        
        try:
            # Extraer tokens del formulario anterior
            tokens = self._extraer_tokens_formulario(self.ultima_respuesta)
            
            # Datos del formulario
            data = {
                "sede": "12408",           # CNP COMISARIA CASTELLON
                "tramiteGrupo[0]": "4010", # POLICIA-CERTIFICADOS
                "tramiteGrupo[1]": "",
                "provincia": "12",
                **tokens
            }
            
            headers = {
                "Content-Type": "application/x-www-form-urlencoded",
                "Referer": "https://icp.administracionelectronica.gob.es/icpplus/citar?p=12&locale=es",
                "Origin": "https://icp.administracionelectronica.gob.es"
            }
            
            response = self.session.post(url, data=data, headers=headers, timeout=30)
            response.raise_for_status()
            
            self.ultima_respuesta = response.text
            self._guardar_html(response.text, "paso3_oficina")
            
            logging.info("âœ… Paso 3: Oficina y trÃ¡mite configurados")
            return True
            
        except Exception as e:
            logging.error(f"âŒ Error en paso 3: {e}")
            return False

    def paso4_entrada_sin_clave(self):
        """Paso 4: Acceso sin Cl@ve"""
        logging.info("ğŸ“ Paso 4: Seleccionando entrada sin Cl@ve...")
        url = "https://icp.administracionelectronica.gob.es/icpplus/acEntrada"
        
        try:
            response = self.session.get(url, timeout=30)
            response.raise_for_status()
            
            self.ultima_respuesta = response.text
            self._guardar_html(response.text, "paso4_entrada")
            
            logging.info("âœ… Paso 4: PÃ¡gina de entrada sin Cl@ve cargada")
            return True
            
        except Exception as e:
            logging.error(f"âŒ Error en paso 4: {e}")
            return False

    def paso5_validar_datos(self):
        """Paso 5: Introducir y validar datos"""
        logging.info("ğŸ“ Paso 5: Validando datos de usuario...")
        url = "https://icp.administracionelectronica.gob.es/icpplus/acValidarEntrada"
        
        try:
            tokens = self._extraer_tokens_formulario(self.ultima_respuesta)
            
            data = {
                "nie": self.TEST_NIE,
                "nombre": self.TEST_NOMBRE,
                "paisNacimiento": "",
                "annoNacimiento": "",
                **tokens
            }
            
            headers = {
                "Content-Type": "application/x-www-form-urlencoded",
                "Referer": "https://icp.administracionelectronica.gob.es/icpplus/acEntrada",
                "Origin": "https://icp.administracionelectronica.gob.es"
            }
            
            response = self.session.post(url, data=data, headers=headers, timeout=30)
            response.raise_for_status()
            
            self.ultima_respuesta = response.text
            self._guardar_html(response.text, "paso5_validar")
            
            logging.info("âœ… Paso 5: Datos validados correctamente")
            return True
            
        except Exception as e:
            logging.error(f"âŒ Error en paso 5: {e}")
            return False

    def paso6_verificar_citas(self):
        """Paso 6: Verificar disponibilidad de citas"""
        logging.info("ğŸ“ Paso 6: Verificando disponibilidad de citas...")
        url = "https://icp.administracionelectronica.gob.es/icpplus/acCitar"
        
        try:
            response = self.session.get(url, timeout=30)
            response.raise_for_status()
            
            self.ultima_respuesta = response.text
            self._guardar_html(response.text, "paso6_citas")
            
            # AnÃ¡lisis del contenido
            contenido = response.text.lower()
            
            # Patrones de NO disponibilidad
            no_disponible = [
                "no hay citas disponibles",
                "no existen citas",
                "en este momento no hay citas",
                "actualmente no hay citas",
                "sin citas disponibles"
            ]
            
            # Patrones de SÃ disponibilidad
            si_disponible = [
                "seleccione fecha",
                "seleccionar fecha",
                "calendario",
                "ui-datepicker",
                "fechas disponibles"
            ]
            
            # Determinar disponibilidad
            if any(patron in contenido for patron in no_disponible):
                hay_citas = False
                mensaje = "âŒ NO HAY CITAS DISPONIBLES (confirmado por texto)"
                logging.info(mensaje)
            elif any(patron in contenido for patron in si_disponible):
                hay_citas = True
                mensaje = "ğŸ‰ Â¡HAY CITAS DISPONIBLES! (calendario detectado)"
                logging.critical(mensaje)
            else:
                # AnÃ¡lisis mÃ¡s profundo con BeautifulSoup
                soup = BeautifulSoup(response.text, 'html.parser')
                elementos_citas = (
                    soup.find('div', class_='ui-datepicker') or
                    soup.find('input', {'type': 'date'}) or
                    soup.find('select', {'name': re.compile('fecha', re.I)})
                )
                
                if elementos_citas:
                    hay_citas = True
                    mensaje = "ğŸ‰ Â¡HAY CITAS DISPONIBLES! (elementos de fecha detectados)"
                    logging.critical(mensaje)
                else:
                    hay_citas = False
                    mensaje = "âš ï¸  Estado indeterminado - No se detectaron citas claras"
                    logging.warning(mensaje)
            
            return {
                "hay_citas": hay_citas,
                "mensaje": mensaje,
                "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
                "url_final": response.url
            }
            
        except Exception as e:
            logging.error(f"âŒ Error en paso 6: {e}")
            return {
                "hay_citas": False,
                "mensaje": f"Error en verificaciÃ³n: {str(e)}",
                "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
                "url_final": url
            }

    def verificar_disponibilidad_completa(self):
        """Ejecuta el flujo completo de verificaciÃ³n"""
        logging.info("ğŸš€ === INICIANDO VERIFICACIÃ“N COMPLETA DE CITAS ===")
        
        try:
            # Reiniciar sesiÃ³n para cada verificaciÃ³n
            self.session.close()
            self.session = requests.Session()
            self.session.verify = certifi.where()
            self.session.headers.update({
                "User-Agent": "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 "
                              "(KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
                "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8",
                "Accept-Language": "es-ES,es;q=0.9",
            })
            
            # Ejecutar flujo paso a paso
            pasos = [
                ("PÃ¡gina inicial", self.paso1_pagina_inicial),
                ("Seleccionar provincia", self.paso2_seleccionar_provincia), 
                ("Configurar oficina", self.paso3_oficina_tramite),
                ("Entrada sin clave", self.paso4_entrada_sin_clave),
                ("Validar datos", self.paso5_validar_datos)
            ]
            
            for nombre_paso, funcion_paso in pasos:
                if not funcion_paso():
                    return {
                        "hay_citas": False,
                        "mensaje": f"Error en: {nombre_paso}",
                        "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                    }
                self._esperar()  # Espera Ã©tica entre pasos
            
            # Verificar citas (paso final)
            resultado = self.paso6_verificar_citas()
            
            # Procesar resultado
            self.guardar_resultado(resultado)
            
            if resultado["hay_citas"]:
                self.crear_alerta_local(resultado)
                self.enviar_notificacion_email(resultado)
            
            return resultado
            
        except Exception as e:
            logging.error(f"âŒ Error durante verificaciÃ³n completa: {e}")
            return {
                "hay_citas": False,
                "mensaje": f"Error general: {str(e)}",
                "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            }
        finally:
            logging.info("ğŸ === VERIFICACIÃ“N COMPLETA FINALIZADA ===\n")

    def guardar_resultado(self, resultado):
        """Guarda resultado en CSV con ruta absoluta"""
        csv_path = DATA_DIR / "resultados_citas.csv"
        es_nuevo = not csv_path.exists()
        
        try:
            with open(csv_path, "a", encoding="utf-8") as f:
                if es_nuevo:
                    f.write("timestamp,hay_citas,mensaje,url_final\n")
                f.write(f'{resultado["timestamp"]},{resultado["hay_citas"]},"{resultado["mensaje"]}",{resultado.get("url_final", "N/A")}\n')
            logging.info("ğŸ’¾ Resultado guardado en CSV")
        except Exception as e:
            logging.error(f"âŒ Error guardando resultado: {e}")

    def crear_alerta_local(self, resultado):
        """Crea archivo de alerta en data/"""
        alert_path = DATA_DIR / "ğŸš¨_CITAS_DISPONIBLES_ğŸš¨.txt"
        try:
            with open(alert_path, "w", encoding="utf-8") as f:
                f.write("ğŸš¨ğŸš¨ğŸš¨ Â¡Â¡Â¡CITAS DISPONIBLES DETECTADAS!!! ğŸš¨ğŸš¨ğŸš¨\n\n")
                f.write(f"ğŸ“… Fecha y hora: {resultado['timestamp']}\n")
                f.write(f"ğŸ’¬ Detalle: {resultado['mensaje']}\n")
                f.write(f"ğŸ”— URL: {resultado.get('url_final', 'N/A')}\n\n")
                f.write("ğŸš€ ACCIÃ“N INMEDIATA REQUERIDA:\n")
                f.write("1. Ve AHORA al sitio web oficial\n")
                f.write("2. Reserva la cita MANUALMENTE\n")
                f.write("3. NO uses bots para reservar\n\n")
                f.write("âš–ï¸  RECORDATORIO: Solo verificaciÃ³n, no reserva automÃ¡tica\n")
            logging.critical("ğŸš¨ Â¡ARCHIVO DE ALERTA CREADO! Revisa data/")
        except Exception as e:
            logging.error(f"âŒ Error creando alerta: {e}")

    def enviar_notificacion_email(self, resultado):
        """EnvÃ­a notificaciÃ³n por email si estÃ¡ configurado"""
        config_path = CONFIG_DIR / "email_config.json"
        if not config_path.exists():
            logging.info("ğŸ“§ Email no configurado")
            return
            
        try:
            with open(config_path, "r", encoding="utf-8") as f:
                config = json.load(f)
                
            msg = MIMEMultipart()
            msg["From"] = config["email"]
            msg["To"] = config["destinatario"]
            msg["Subject"] = "ğŸš¨ ALERTA: CITAS EXTRANJERÃA DISPONIBLES"
            
            cuerpo = f"""
Â¡CITAS DISPONIBLES DETECTADAS!

Timestamp: {resultado['timestamp']}
Mensaje: {resultado['mensaje']}
URL: {resultado.get('url_final', 'N/A')}

IMPORTANTE: Accede manualmente al sitio para reservar.
Este bot solo verifica disponibilidad.
"""
            msg.attach(MIMEText(cuerpo, "plain", "utf-8"))
            
            with smtplib.SMTP(config["smtp_server"], config["smtp_port"]) as server:
                server.starttls()
                server.login(config["email"], config["password"])
                server.sendmail(config["email"], config["destinatario"], msg.as_string())
                
            logging.info("ğŸ“§ NotificaciÃ³n enviada por email")
            
        except Exception as e:
            logging.error(f"âŒ Error enviando email: {e}")

    def monitor_continuo(self, intervalo_minutos=10, max_verificaciones=None):
        """Monitor continuo con control Ã©tico"""
        logging.info("ğŸ”„ === INICIANDO MONITOR CONTINUO ===")
        logging.info(f"â±ï¸  Intervalo: {intervalo_minutos} minutos")
        logging.info(f"ğŸ”¢ MÃ¡ximo verificaciones: {'Ilimitado' if not max_verificaciones else max_verificaciones}")
        
        contador = 0
        try:
            while True:
                contador += 1
                logging.info(f"\nğŸ“Š --- VerificaciÃ³n #{contador} ---")
                
                resultado = self.verificar_disponibilidad_completa()
                
                if resultado["hay_citas"]:
                    logging.critical("ğŸ‰ Â¡CITAS ENCONTRADAS! Revisa el sitio web INMEDIATAMENTE")
                    # Opcional: hacer verificaciones adicionales
                    for i in range(2):
                        time.sleep(30)
                        logging.info(f"ğŸ”„ VerificaciÃ³n adicional {i+1}/2...")
                        self.verificar_disponibilidad_completa()
                
                if max_verificaciones and contador >= max_verificaciones:
                    logging.info("âœ… LÃ­mite de verificaciones alcanzado")
                    break
                
                # Esperar hasta la prÃ³xima verificaciÃ³n
                logging.info(f"ğŸ’¤ PrÃ³xima verificaciÃ³n en {intervalo_minutos} minutos...")
                time.sleep(intervalo_minutos * 60)
                
        except KeyboardInterrupt:
            logging.info("\nâ¹ï¸  Monitor detenido por el usuario (Ctrl+C)")
        finally:
            logging.info("ğŸ === MONITOR FINALIZADO ===")

    def menu_principal(self):
        """MenÃº interactivo principal"""
        print("=" * 70)
        print("ğŸ” BOT VERIFICADOR DE CITAS EXTRANJERÃA - CASTELLÃ“N")
        print("=" * 70)
        print("ğŸ“‹ PropÃ³sito: Ayuda social - Solo verificaciÃ³n de disponibilidad")
        print("âš–ï¸  Legal: NO reserva citas, solo detecta disponibilidad")
        print("ğŸ›¡ï¸  Ã‰tico: Respeta lÃ­mites del servidor con esperas")
        print("=" * 70)
        
        while True:
            print("\nğŸ“‹ OPCIONES DISPONIBLES:")
            print("1ï¸âƒ£  VerificaciÃ³n Ãºnica completa")
            print("2ï¸âƒ£  Monitor continuo (cada 10 min)")
            print("3ï¸âƒ£  Monitor personalizado")
            print("4ï¸âƒ£  Configurar notificaciones email")
            print("5ï¸âƒ£  Ver Ãºltimos resultados")
            print("0ï¸âƒ£  Salir")
            
            try:
                opcion = input("\nğŸ‘‰ Selecciona opciÃ³n: ").strip()
                
                if opcion == "1":
                    print("\nğŸ” Ejecutando verificaciÃ³n Ãºnica...")
                    resultado = self.verificar_disponibilidad_completa()
                    print(f"\nğŸ“Š Resultado: {resultado['mensaje']}")
                    
                elif opcion == "2":
                    print("\nğŸ”„ Iniciando monitor continuo...")
                    print("ğŸ’¡ Presiona Ctrl+C para detener")
                    self.monitor_continuo(intervalo_minutos=10)
                    
                elif opcion == "3":
                    minutos = int(input("â±ï¸  Intervalo en minutos: ") or "10")
                    max_ver = input("ğŸ”¢ MÃ¡ximo verificaciones (Enter = ilimitado): ").strip()
                    max_ver = int(max_ver) if max_ver else None
                    self.monitor_continuo(intervalo_minutos=minutos, max_verificaciones=max_ver)
                    
                elif opcion == "4":
                    self.configurar_email_interactivo()
                    
                elif opcion == "5":
                    self.mostrar_resultados_recientes()
                    
                elif opcion == "0":
                    print("\nğŸ‘‹ Â¡Gracias por usar el verificador!")
                    print("ğŸ¤ Recuerda: Solo para ayuda social")
                    break
                    
                else:
                    print("âŒ OpciÃ³n no vÃ¡lida")
                    
            except KeyboardInterrupt:
                print("\nâ¹ï¸  OperaciÃ³n cancelada")
                continue
            except Exception as e:
                print(f"âŒ Error: {e}")

    def configurar_email_interactivo(self):
        """ConfiguraciÃ³n interactiva de email"""
        print("\nğŸ“§ CONFIGURACIÃ“N DE NOTIFICACIONES EMAIL")
        print("=" * 50)
        try:
            smtp_server = input("ğŸ“¡ Servidor SMTP (ej: smtp.gmail.com): ")
            smtp_port = int(input("ğŸ”Œ Puerto SMTP (ej: 587): "))
            email = input("ğŸ“§ Tu email: ")
            password = input("ğŸ”‘ ContraseÃ±a/App Password: ")
            destinatario = input("ğŸ“® Email destinatario: ")
            
            config = {
                "smtp_server": smtp_server,
                "smtp_port": smtp_port,
                "email": email,
                "password": password,
                "destinatario": destinatario
            }
            
            config_path = CONFIG_DIR / "email_config.json"
            with open(config_path, "w", encoding="utf-8") as f:
                json.dump(config, f, indent=2)
            
            print("âœ… ConfiguraciÃ³n de email guardada")
            
        except Exception as e:
            print(f"âŒ Error en configuraciÃ³n: {e}")

    def mostrar_resultados_recientes(self):
        """Muestra los Ãºltimos resultados"""
        csv_path = DATA_DIR / "resultados_citas.csv"
        if not csv_path.exists():
            print("â„¹ï¸  No hay resultados previos")
            return
            
        try:
            with open(csv_path, "r", encoding="utf-8") as f:
                lineas = f.readlines()
            
            print(f"\nğŸ“Š ÃšLTIMOS {min(10, len(lineas)-1)} RESULTADOS:")
            print("=" * 50)
            
            for linea in lineas[-10:]:
                if not linea.startswith("timestamp"):
                    print(linea.strip())
                    
        except Exception as e:
            print(f"âŒ Error leyendo resultados: {e}")

def main():
    """FunciÃ³n principal"""
    try:
        bot = CitasExtranjeriaBot()
        bot.menu_principal()
    except Exception as e:
        logging.error(f"âŒ Error crÃ­tico en main: {e}")
        print(f"âŒ Error crÃ­tico: {e}")

if __name__ == "__main__":
    main()
